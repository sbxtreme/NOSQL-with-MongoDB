/****************************************/
/****************************************/
/      INTRODUCTION TO NOSQL & JSON	 /
/****************************************/
/****************************************/


For non structured data we use json.

JSON stands for javascript object notation.

Json is based on javascript which is basically a standard to exchange data between client and server. Before Json , xml was used to exchange data between systems but JSON being easy to read, light and less complicated is used mostly now and becoming the standard for data exchange.

In Json there is a concept of key:value pairs. In a json object there can be number of key value pairs and again inside key there can be json objects which further can be treated as key:values or can have json array inside json object.

ex:

JSON inside JSON object:
------------------------
myObj = {
    "name":"John",
    "age":30,
    "cars": {
        "car1":"Ford",
        "car2":"BMW",
        "car3":"Fiat"
    }
 }


Array inside Json object:
-------------------------

{
"name":"John",
"age":30,
"cars":[ "Ford", "BMW", "Fiat" ]
}


Data types in JSON:
-------------------

1) Numbers: No difference between integer and float
2) String: Use double quotes to represent the strings
3) Boolean: True or False
4) Arrays: Ordered list of values
5) Objects: combination of key-value pairs
6) NULL: Empty values


Example :

{
	"name": "Shobhit",
	"age": 26,
	"address": {
		"street": "MGROAD",
		"city": "Gurgaon",
		"state": "Haryana",
		"pin": 122001
	},
	"organization": "ITC",
	"technology": ["Mongodb", "Machine Learning", "Python", "SQL", "Informatica", "UNIX"]
}

The data is stored in Mongodb in BSON format which is a superset of JSON. The binary json in called BSON.
In order to perform operations on unstructured data we use NOSQL ( not only structured query language).


/****************************************/
/****************************************/
/  INTRODUCTION TO MONGODB - DOC TYPE DB /
/****************************************/
/****************************************/


Mongo db is a document based NOSQL database.
It uses BSON for storing data in database.
It stores unstructured data in BSON format.
It is not relational database.
It's an opensource database.
The data is stored in the form of collections.
The database is schemaless i.e there is no restriction or predefined columns with datatypes to store specific values.

Mongodb vs RDBMS

1) collections vs tables
2) documents(BSON) vs rows
3) fields vs columns

Structure of Mongodb:

Database--> Collections--> Documents

In order to connect to mongodb following needs to be done.
1) install mongodb
2) set environment path
3) go to cmd and type mongod.exe which is mongodb demon.
4) open another cmd and type mongo.exe to start mongo cmd prompt.
5) instead of mongo cmd prompt we can use studio 3t which gives additional features and from there we can perform different database operations.
6) In the tool create connection and open Intellishell and start writing mongodb commands.

**************************
MongoDB Datamodelling:
**************************

Mongodb datamodelling
----------------------

1) The documents are stored in mongodb in the form of bson which is binary json. BSON is a binary serialization format used to store documents and make remote procedure calls in MongoDB.The reason for storing in bson format is because it is lightweight and faster.

2) In case of RDBMS , the schemas are fixed where as in case of Nosql the schemas are flexible.In Mongodb the collections can store documents of different structures.


3) In case of MongoDB all the crud operations can be done using json.We just have to pass json in the mongodb functions. ex:
-- insert : db.emp.insert({"empname":"shobhit"})
-- select : db.emp.find({"empname":"shobhit","age":10})

4) Post 3.0 version, The max size of documents in Mongodb is 16mb but if documents are greater than 16mb still mongodb will store but it will store in the form of mongo files which is a binary file called as GRIDFS.

5) Below conventions must be followed in mongodb:
 a) the key names should not contain . i.e {"first.name":"shobhit"} # error
 b) the key should not contain $ i.e {"first$name":"shobhit"} # error

 . is used for traversing into the documents i.e
 {name:{first:"shobhit",last:"bhatnagar"}}
 so we can find the above document in mongodb using find() i.e db.collectionname.find({"name.first":"shobhit"})

$ is used with the operators like $gte,$and,$not etc..

6) In mongodb there is going to a primary key which will be autogenerated key using which we can identify the documents, which is "_id" field. This "_id" field is called as object id. We can also explicitly give the _id to our documents while inserting but if we don't give mongodb will automatically generate the id field.
There are 3 limitations for this field:
 a) It should not be null
 b) It should not be duplicate
 c) It should not of type array


Note:
-----

 In mongodb it supports 3 types of storage engines. They are :
 1) MMAPV1 
 --> entire collection will be locked and no updates will run on any of the document if someone is updating any 1 of the documents.
 2) WiredTiger 
 --> only a document which is modified will be locked but entire collection will not be locked. Due to this any other document can also be modified.
 3) InMemory 



7) There are 2 types of data modelling in Mongodb. They are:
 a) Embedded data modelling:
 --------------------------
 
	Lets take an example of student data , in this data we have details about students registration , student class/semesters and student exam details. In All the 3 cases student id will be same and there might be some field which will be common like class in class details and class in exam details , so instead of creating 3 different collections , we will create a single collection which will have embadded documents i.e in a single 
	document all the details will be present . Below are the benifits of embadded documents.

	-- No need to join different collections , a single find operation will give all the details about student.
	   also a single update will update the values of a document.

	-- Atomic operations can be applied at document level i.e either all will be updated or nothing will be updated, this will help to reduce data inconsistency where as if the collections are different then there might be chances that 1 collection document is updated while the other is left.

Disadvantage:
1) Size of documents will be more as all the details are embadded in a single document.
2) Changes of high redundency.


 b) Reference data modelling:
 ----------------------------
 	This model is used for normalized data i.e don't keep the data in a single document instead keep the data into multiple documents i.e 1 document for student admin details , 1 for class details and 1 for exam details and join all the 3 documents using linked keys. _id by default is used to link 2 or more documents. 


GRIDFS:
-------
If the document is more than 16mb then GRIDFS will break the files into 256kb files i.e into chuncks 
and store it in database. Here there are 2 parts, 1 which stores the data and 1 which stores the metadata that which file data is stored where.

There are 3 types of relations in mongodb data which can be maintained:
1) one to one ---- go with embedded documents
2) one to many ---- go with embedded documents
3) many to many ---- go with linked documents as in case of embadded size will increase.





/****************************************/
/****************************************/
/             MongoDB Commands           /
/****************************************/
/****************************************/


//*************** database-->collections(tables in RDBMS)-->documents(rows in RDBMS) ******************

// list current database
db

// create or switch database
use database1
use database2

// show databases
show dbs // the newly created databases are not show because there is no documents in it.

// command to insert document ( the document is in JSON format i.e key-value pairs )
db.mycollection.insert({
	"name": "Shobhit",
	"age": 26,
	"address": {
		"street": "MGROAD",
		"city": "Gurgaon",
		"state": "Haryana",
		"pin": 122001
	},
	"organization": "ITC",
	"technology": ["Mongodb", "Machine Learning", "Python", "SQL", "Informatica"]
}
)

// inserting document in database2
use database2
db.mycollection.insert({
	"name": "Shobhit",
	"age": 26,
	"address": {
		"street": "MGROAD",
		"city": "Gurgaon",
		"state": "Haryana",
		"pin": 122001
	},
	"organization": "ITC",
	"technology": ["Mongodb", "Machine Learning", "Python", "SQL", "Informatica"]
}
)

// command to drop database. The below command will drop the current database in which the user is switched in.
db.dropDatabase()

// command to create collections in database
db.createCollection("mycollection_1")
db.createCollection("mycollection_2")
// command to see collections present in a database
show collections
// command to drop collections -- db.<collection_name>.drop()
db.mycollection_2.drop()

// insert bulk in collections ( creating collection named student and inserting records in the form of JSON document.)

db.students.insert
(
[
		{
			"name":"shobhit",
			"class":10,
			"skills":"db",
		},
		{
			"name":"mark",
			"class":10,
			"skills":"db2",
		},
		{
			"name":"paul",
			"class":10,
			"skills":"db2",
		},
		{
			"name":"henry",
			"class":11,
			"skills":"db",
		},
		{
			"name":"alok",
			"class":12,
			"skills":"nosqldb",
		},
		{
			"name":"shobhit",
			"class":10,
			"skills":"nosqldb",
		}
]
)


// command to query the collection inside the database to get documents.
db.mycollection.find()
db.students.find()
db.students.findOne() // will show 1st document from collection students
db.students.find({"name":"alok"}) // where name = 'alok'
db.students.find({"class":10}) // where class=10
db.students.find      // will show class greater than 10
(
	{
		"class": {$gt : 10}
	}
)

db.students.find // will show class greater than or equal to 11
(
	{
		"class": {$gte : 11}
	}
)

db.students.find // will show class less than or equal to 11
(
	{
		"class":{$lte : 11}
	}
)

db.students.find
(
	{
		"class":{$ne :10}
	}
)

// the below command uses AND condition in a collection to get documents
db.students.find({"class":10,"skills":"db"}) // here , is used as AND condition

// the below command uses OR condition in a collection to get documents
db.students.find
(
	{
		$or : [{"name":"shobhit"},{"class":12}]
	}
)


// the below command uses AND and OR conditions
db.students.find
(
{
  "name":"shobhit" , $or : [{"class":10},{"skills":"db"}]
}
)


// command to update the documents inside collections
db.students.update
(
	{"name":"shobhit"},  // condition on which update will run
	{$set:{"skills":"Mongodb"}}, // key's value which needs to be updated
	{multi:true} // if there are multiple documents which needs to be updated in 1 go then use multi:true (by default mongo will only update 1st row)
)


// command to update / insert data using json (document) supplied to the command
db.students.save    // save method is used to update / insert document based on id present in collection
(
	{ 
		"_id" : ObjectId("5a26b783ec58bcc914a0cae1"),   // if this id is not present in collection then it will insert else it will update
		"name" : "Johny", 
		"class" : 10.0, 
		"skills" : "Mongod"
	}
)


// command to delete documents from a collection
db.students.remove()  // the command will delete all the documents from collection , so be careful with this command.
db.students.remove({"name" : "shobhit"}) // here we give condition based on which the documents will be deleted/removed from collection
db.students.remove({"name" : "shobhit"},1) // if 2 documents satisfies the conditions then passing 1 will delete only 1 document
// OR and AND conditions can be used to remove the documents 
db.students.remove
(
	{
		$or : [{"skills":"db"},{"skills":"db2"}]
	}
)

// Projection in Mongodb i.e selecting only the specific data attribute(columns) from all the documents(records) present in a collection(table)
db.students.find({},{"name":1}) // it will show only name attribute and hide all others
db.students.find({},{"name":0}) // it will hide name attributes and will show all others
// by default _id is always shown while executing the above command so we need to explicitly disable it. To do so we use the below command
db.students.find({},{"name":1,"_id":0}) // it will only show name -- no id along with name

// Limit, skip and sort operations on documents in a collection.
db.students.find().skip(2) // this will skip first 2 records and will show last 4 records
db.students.find().limit(4) // this will show 1st 4 rocords and skip last 2 records
db.students.find().sort({"name":-1}) // this will sort the documents based on name attribute in decending order
db.students.find().sort({"name":1}) // this will sort the documents based on name attribute in ascending order

// command to create index
//-- the below command creates documents using loop --
for (i=0;i<1000000;++i)
{
	db.largecoll.insert({"sid":i,"subject":"maths"})
}
// the below command creates index on sid in the documents
db.largecoll.ensureIndex({"sid":1})
// the below command is to drop index
db.largecoll.dropIndex({"sid":1})


// commands to use aggrigation function based on grouping in documents
db.stu.aggregate
(
	[
		{$group:{_id:"$gender",result:{$sum:1}}}
	]
)
db.stu.aggregate
(
	[
		{$group:{_id:"$gender",result:{$max:"$class"}}}
	]
)
db.stu.aggregate
(
	[
		{$group:{_id:"$gender",result:{$min:"$class"}}}
	]
)
